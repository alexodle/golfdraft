{
  "name": "react-async",
  "version": "0.9.2",
  "description": "React addon to render async components on server",
  "main": "index.js",
  "browser": "browser.js",
  "peerDependencies": {
    "react": "~0.10.0"
  },
  "devDependencies": {
    "fibers": "~1.0.1",
    "semver": "~2.2.1",
    "jshint": "~2.4.3",
    "connect-browserify": "~1.0.0",
    "express": "~3.4.8",
    "mocha": "~1.17.1",
    "node-dev": "~2.1.6",
    "react": "~0.10.0",
    "mocaccino": "^0.4.2",
    "phantomic": "^0.5.0",
    "phantomjs": "^1.9.7-1",
    "uglify-js": "^2.4.13",
    "browserify": "^3.32.1",
    "browserify-shim": "^3.3.1"
  },
  "scripts": {
    "test": "make test"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/andreypopp/react-async"
  },
  "keywords": [
    "react-component",
    "async",
    "server-rendering",
    "react"
  ],
  "author": {
    "name": "Andrey Popp",
    "email": "8mayday@gmail.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/andreypopp/react-async/issues"
  },
  "homepage": "https://github.com/andreypopp/react-async",
  "dependencies": {
    "ascii-json": "~0.2.0"
  },
  "readme": "# React Async\n\nReact Async is an addon for React which allows to define and render components\nwhich require a part of its state to be fetched via an asynchronous method (for\nexample using an XHR request to get data from a server).\n\nWe call this type of components *asynchronous components*.\n\n## Concept\n\nIn the first place, React Async is a contract for React components which need\npart of their state to be fetched asynchronously.\n\nThe contract specifies the following requirements:\n\n  * Component can fetch part of its state by specifying\n    `getInitialStateAsync(cb)` method which takes Node-style callback function\n    as an argument.\n\n  * Implementation of `getInitialStateAsync(cb)` can only access properties of\n    a component.\n\n  * Component should provide `render()` implementation which can render in\n    absence of asynchronous part of the state.\n\n  * The state can be injected into a component by providing `asyncState`\n    property. In this case `getInitialStateAsync(cb)` method isn't called.\n    This should be used for testing purposes only.\n\nAlso React Async provides a mixin which implements such contract and a set of\nutilities for working with asynchronous components.\n\n## Installation\n\nReact Async is packaged on npm:\n\n    % npm install react-async\n\n## Usage\n\nTo create an asynchronous component you use a `ReactAsync.Mixin` mixin and\ndeclare `getInitialStateAsync(cb)` method:\n\n    var React = require('react')\n    var ReactAsync = require('react-async')\n\n    var Component = React.createClass({\n      mixins: [ReactAsync.Mixin],\n\n      getInitialStateAsync: function(cb) {\n        xhr('/api/data', function(data) {\n          cb(null, data)\n        }.bind(this))\n      },\n\n      render: function() { ... }\n    })\n\nThe method `getInitialStateAsync` mimics `getInitialState` but can fetch state\nasynchronously. The result of the function is mixed in into the component state.\n\n## Deferring rendering of async components\n\nIf you want to render different async components in the same DOM node and don't\nwant to unmount already rendered component unless async state of the next\ncomponent is fetched, there's `<Preloaded />` component which handles that:\n\n    <Preloaded>\n      {this.renderAsyncTabContents({url: this.state.url})\n    </Preloader>\n\nIt accepts only a single child and only that single child could be an async\ncomponent. On first render it would render its child as-is but on subsequent\nrenders it would defer rendering unless async state is prefetched.\n\nIf you want to defer first render unless async state is fetched you should\nprovide a `preloader` prop:\n\n    <Preloaded preloader={Spinner()}>\n      {this.renderAsyncTabContents({url: this.state.url})\n    </Preloader>\n\nYou also can force preloader on subsequent renders with `alwayUsePreloader`\nprop:\n\n    <Preloaded preloader={Spinner()} alwayUsePreloader>\n      {this.renderAsyncTabContents({url: this.state.url})\n    </Preloader>\n\n## Rendering async components on server with fetched async state\n\nThe problem arises when you want to render UI on server with React.\n\nWhile React provides `renderComponentToString` function which can produce markup\nfor a component, this function is synchronous. That means that it can't be used\nwhen you want to get markup from server populated with data.\n\nReact Async provides another function `renderComponentToStringWithAsyncState`\nwhich is asynchronous and triggers `getInitialStateAsync` calls in the component\nhierarchy.\n\nFirst, you'd need to install `fibers` package from npm to use that function:\n\n    % npm install fibers\n\nThen use it like:\n\n    ReactAsync.renderComponentToStringWithAsyncState(\n      Component(),\n      function(err, markup) {\n        // send markup to browser\n      })\n\nThis way allows you to have asynchronous components arbitrary deep in the\nhierarchy.\n\n### Manually injecting fetched state\n\nIf you'd need more control over how state is injected into your markup you can\npass a third argument to the `renderComponentToStringWithAsyncState` callback\nfunction which contains a snapshot of the current server state:\n\n    ReactAsync.renderComponentToStringWithAsyncState(\n      Component(),\n      function(err, markup, data) {\n        ...\n      })\n\nYou can then do your own manual injection or use the `injectIntoMarkup` method.\nIn addition to injecting the current server state, `injectIntoMarkup` can also\nreference your client script bundles ensuring server state is available before\nthey are run:\n\n    ReactAsync.renderComponentToStringWithAsyncState(\n      Component(),\n      function(err, markup, data) {\n        res.send(ReactAsync.injectIntoMarkup(markup, data, ['./client.js']))\n      })\n\nThis produces the following markup:\n\n      ...\n\n      <script>\n        window.__reactAsyncStatePacket = {\n          \".1p74iy9hgqo.1.0__5\": {\n            \"message\":\"Hello\"\n          }\n        }\n      </script>\n      <script src=\"./client.js\"></script>\n    </body>\n\n### Custom state serialization and deserialization\n\nYou can provide `stateToJSON(state)` and `stateFromJSON(data)` methods to\ncustomize how async state is serialized/deserialized when it is transfered to a\nbrowser from a server.\n\nThat allows keeping objects in state which are not POJSOs (Plain JS Objects),\nfor example:\n\n    ...\n\n    getInitialStateAsync: function(cb) {\n      cb(null, {message: new Message('Hello')})\n    },\n\n    stateFromJSON: function(state) {\n      return {message: new Message(state.message.msg)}\n    },\n\n    stateToJSON: function(state) {\n      return {message: {msg: state.message.msg}}\n    },\n\n    render: function() {\n      return (\n        <div>\n          {this.state.message ? this.state.message.say() || 'Loading'}\n        </div>\n      )\n    },\n\n    ...\n\nWhere `Message` is a class defined as:\n\n    function Message(msg) {\n      this.msg = msg\n    }\n\n    Message.prototype.say = function() {\n      return this.msg\n    }\n\n## API reference\n\n#### **ReactAsync.Mixin**\n\nComponents which uses this mixin should define `getInitialStateAsync(cb)` method\nto fetch a part of its state asynchronously.\n\nOptionally components could define `stateToJSON(state)` and\n`stateFromJSON(data)` methods to customize how state serialized and deserialized\nwhen it's transfered to a browser.\n\n#### **ReactAsync.renderComponentToStringWithAsyncState(component, cb)**\n\nRenders component to a markup string while  calling `getInitialStateAsync(cb)`\nmethod of asynchronous components in the component hierarchy.\n\nThis guarantees that components will have their state fetched before calling its\n`render()` method.\n\nCallback `cb` is called with either two or three arguments (depending on the\narity of the callback itself).\n\nIn the case of two arguments `err` and `markup`, async state data will already be\ninjected into `markup` to reproduce the same UI in a browser.\n\nIn the case of three arguments `err`, `markup` and `data`, an API consumer should\ninject data manually (for example using `injectIntoMarkup(markup, data,\nscripts)` function.\n\nYou'd need to have `fibers` package from npm installed to use this function:\n\n    % npm install fibers\n\n#### **ReactAsync.isAsyncComponent(component)**\n\nReturns `true` if a `component` is an asynchronous component.\n\n#### **ReactAsync.prefetchAsyncState(component, cb)**\n\nPrefetch the asynchronous state of a `component` by calling its\n`getInitialStateAsync(cb)` method. Note that only an async state of the\ncomponent itself would be prefetched but not of its children.\n\nCallback `cb` is called with two arguments `err` and `component`, where\n`component` is a clone of a original component with its state injected.\n\nPrefetching should be done before mounting a component into DOM.\n\n#### **ReactAsync.injectIntoMarkup(markup, data, scripts)**\n\nInject `data` into `markup` as JSON blob. Data will be injected as:\n\n    window.__reactAsyncStatePacket = { ... }\n\nThis allows to transfer asynchronous state fetched on server to browser. That\nway components in browser won't need to call `getInitialStateAsync(cb)` method\nonce more on first render.\n\nIf `scripts` is passed and is an array then inject `<script src=\"...\"></script>`\ninto the `markup` for each element of the array.\n",
  "readmeFilename": "README.md",
  "_id": "react-async@0.9.2",
  "dist": {
    "shasum": "6b7c73cdef911a0c5a680efefcfa642800a99dbe"
  },
  "_from": "react-async@~0.9.1",
  "_resolved": "https://registry.npmjs.org/react-async/-/react-async-0.9.2.tgz"
}
